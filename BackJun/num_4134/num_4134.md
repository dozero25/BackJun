![스크린샷 2025-04-08 122030](https://github.com/user-attachments/assets/188c8fea-85b6-453a-8036-411b7a4b83f7)

1. long
- 문제에서 정수 n의 최댓값이 int형의 최댓값을 초과하기 때문에 Long으로 값을 받아 NumberFormatException 오류 방지
- pri값 이상의 가장 작은 소수를 구하기 위해 for문 실행
- calcPrimeNumber() 메서드가 true이면 출력

2. calcPrimeNumber()
- 소수를 구하기 위한 메서드
- n이 2보다 작으면 소수가 아니기 때문에 false 리턴
- for문을 사용해 소수 계산
- Math.sqrt()를 사용해 불필요한 반복을 줄임
- 합성수는 1과 자기 자신 이외의 약수를 하나 이상 가지며, 그 중 하나는 반드시 √n 이하임 따라서 소수 판별 시 2부터 √n까지만 확인
- 예시
  - n = 10 -> 2, 5는 10의 약수 → 1과 10을 제외한 약수 존재 -> 합성수
  - n = 36 -> 2, 3, 6, 9, 12, 18 등 다양한 약수 존재 -> 합성수
  - n = 40 -> 2, 4, 5, 8, 10, 20 등 다양한 약수 존재 -> 합성수
- 이런 약수는 곱의 형태 (a * b = n)으로 표현할 수 있음, 이때 a와 b 둘다 √n보다 크면 a * b는 n보다 커지기 때문에 모순 발생
- 따라서, n이 합성수라면 a * b = n을 만족하는 약수 중 적어도 하나는 반드시 √n 이하
- 그래서 소수 판별 시 2부터 √n까지만 나눠봐도 됨
  